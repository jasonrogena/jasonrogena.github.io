<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8"/>
      <script>
         var host = "jasonrogena.github.io";
         if (window.location.host == host && window.location.protocol != "https:") {
            window.location.protocol = "https:";
         }
      </script>
		<title> Sending App Data Over SMS on Android </title>
		<!-- For responsive site
			<meta name="viewport" content="width=device-width, initial-scale=1.0">
		-->
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<link rel="author" href="/humans.txt">
		<meta name="description" content="Description Goes Here">
      <link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css">
		<link rel="stylesheet" href="/css/style.css">
		<!--[if IE 7]>
			<html class="ie7"> 
			<link rel="stylesheet" type="text/css" href="/css/font-awesome-ie7.min.css">
		<![endif]-->
		<!--[if IE 8]><html class="ie8"> <![endif]-->		
	    <!--[if lt IE 9]>
	      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	    <![endif]-->

		<link rel="apple-touch-icon-precomposed" sizes="144x144" href="ico/apple-touch-icon-144-precomposed.png">
		<link rel="apple-touch-icon-precomposed" sizes="114x114" href="ico/apple-touch-icon-114-precomposed.png">
		<link rel="apple-touch-icon-precomposed" sizes="72x72" href="ico/apple-touch-icon-72-precomposed.png">
		<link rel="apple-touch-icon-precomposed" href="ico/apple-touch-icon-57-precomposed.png">
		<link rel="shortcut icon" href="ico/favicon.png">	    
	</head>
	<body>
	<!-- Header
	    ================================================== -->
	<header>

	</header>

	<div class="top-strip"></div>
<main class="content">
    <section class="container">
    	<div class="row-fluid">
    		<article class="home-icon">
				<a href="/">
					<i class="icon-home"></i> 
				</a>
			</article>
			<article class="post">
				<h5>22 December 2013</h5>
				<h2 class="content">Sending App Data Over SMS on Android</h2>
				<section>
					<p>For some time now I’ve been working on <a href="https://github.com/jasonrogena/ngombe_planner-android">an Android app</a> that is going to be used by small scale farmers in East Africa. We expect that most of the farmers will not have an internet connection. Hell, most of them won’t have android phones. But that’s a story for another day. So, for a proof of concept, the app I’m making should roll back to sending data using SMS when no HTTP connection is available. Here some notes on how to do it:</p>

<h3 id="architecture">Architecture</h3>

<p>You’d want to follow an architectural styl, such as <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">REpresentational State Transfer</a>, that explicitly defines the types and structures of messages to be sent between Client and Server. This is very important because you want to keep the intereactions as clean as possible.</p>

<p>In this instance, I did not go the REST way. However, I made up a simple ‘Protocol’ defining intereactions between the Client (Android App) and the Server. Here it goes: <em>All messages sent between the Server and the Client are either json strings or integers. The integers represent predefined acknowledgement and error codes</em>.</p>

<h3 id="make-it-work-well-over-http">Make it work well over HTTP</h3>

<p>As much as I would have wanted to start implementing the SMS functionality from the get go I had to first get the requirements right first. Blame that on the client. So I built, we reviewed. Then I built some more and we reviewed again until all the features were working (although all interactions with the server were through a http connection).</p>

<p>One thing, however, that I had to do was to make sure the app was as modular as possible. Each important function (eg handling notifications or interaction with the server) was handled by one class. For instance all interactions with the server are handled by <a href="https://github.com/jasonrogena/ngombe_planner-android/blob/master/NgombePlanner/src/main/java/org/cgiar/ilri/np/farmer/backend/DataHandler.java">DataHandler.java</a>.</p>

<h3 id="the-sms-server">The SMS Server</h3>

<p>When everything was working fine over HTTP and I was sure it was time to implement message transmission over SMS, we had to choose Server Side Software for handling SMSs. My boss chose <a href="http://www.kannel.org">Kannel</a>. I wouldn’t have chosen anything else. Kannel is free and open. Honestly, I would not recommend Ozeki to anyone. Kannel is a bit hard to configure but once you get things running it is bliss.</p>

<p>Here’s <a href="https://jasonrogena.github.io/2014/01/18/kannel-and-the-huawei-e160.html">another post</a> I wrote on configuring Kannel.</p>

<p>We have two servers in the office, one has all the PHP scripts that interact with the Android app and the other runs Kannel. To make things less complicated I’ll call the server running the PHP scripts Azizi and the one running Kannel KServer. KServer has a Huawei E160 HSPA modem plugged into it. Not the best modem but it works. The KServer acts like a proxy, re-routing SMSs from the Andriod app to Azizi and routing responses from Azizi to the Android app via SMS.</p>

<h3 id="rolling-back-to-sms-on-the-android-app">Rolling back to SMS on the Android App</h3>

<p>Sending SMSs from the Android app is pretty simple. When DataHandler is called, it checks whether it can connect to Azizi over HTTP. It sends the data using SMS if it cannot directly connect to Azizi. Code snippet below shows the method in DataHandler responsible for determining if data should be sent using HTTP or SMS.</p>

<pre><code>public static String sendDataToServer(Context context, String jsonString, String appendedURL, boolean waitForResponse) {
    String response;
    if(checkNetworkConnection(context)){
        response = sendDataUsingHttpConnection(jsonString, appendedURL);
    }
    else{
        response = sendDataUsingSMS(context, jsonString, appendedURL, waitForResponse);
    }
    return response;
}
</code></pre>

<p>The sendDataUsingSMS method is pretty simple. I first created a new <a href="http://developer.android.com/reference/android/telephony/gsm/SmsManager.html">SmsManager</a> Object. Note from the code snippet below that I intend to send multipart SMSs instead of regular SMSs. This is because the text being sent to the server might be greater than 150 characters (limit for one SMS).</p>

<pre><code>SmsManager smsManager = SmsManager.getDefault();
String message = appendedURL+SMS_DELIMITER+jsonString;
ArrayList&lt;String&gt; multipartMessage = smsManager.divideMessage(message);
int noOfParts = multipartMessage.size();
</code></pre>

<p>Then I initialize three <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html">BroadcastReceivers</a>. Basically, what Broadcast receivers do is listen for broadcasted Intents. For instance when an SMS is sent, Android broadcasts the Intent. All BroadcastReceivers that registered to listen for that particular intent will get the broadcast message from Android.</p>

<pre><code>MistroSMSSentReceiver mistroSMSSentReceiver = new MistroSMSSentReceiver(message, noOfParts);    
context.registerReceiver(mistroSMSSentReceiver, new IntentFilter(ACTION_SMS_SENT));
MistroSMSDeliveredReceiver mistroSMSDeliveredReceiver = new MistroSMSDeliveredReceiver(message, noOfParts);
context.registerReceiver(mistroSMSDeliveredReceiver, new IntentFilter(ACTION_SMS_DELIVERED));
if(waitForResponse){//method will be waiting for a response sms from the server
    MistroSMSReceiver mistroSMSReceiver = new MistroSMSReceiver();
    IntentFilter smsReceivedIntentFilter = new IntentFilter(ACTION_SMS_RECEIVED);
    smsReceivedIntentFilter.addAction("android.provider.Telephony.SMS_RECEIVED");
    context.registerReceiver(mistroSMSReceiver, smsReceivedIntentFilter);
}
</code></pre>

<p>As I was saying, I initialize three BroadcastReceivers:</p>

<ol>
  <li>MistroSMSSentReceiver - That listens for when an SMS is sent</li>
  <li>MistroSMSDeliveredReceiver - That listens for when an SMS is delivered</li>
  <li>MistroSMSReceiver - That listens for when an SMS is received</li>
</ol>

<p>All three BroadcastReceivers are inner classes in DataHandler.java that extend BroadcastReceiver.</p>

<p>You might notice from the code snippet above that; MistroSMSSent Receiver will be listening for an intent with the <em>ACTION_SMS_SENT</em> message, MistroSMSDeliveredReceiver will be listening for an intent with the <em>ACTION_SMS_DELIVERED</em> message, and MistroSMSReceiver will be listening for an intent with the message <em>ACTION_SMS_RECEIVED</em>.</p>

<p>Then I register the MistroSMSSentReceiver and MistroSMSDeliveredReceiver for each of the SMS fragments to be sent.</p>

<pre><code>ArrayList&lt;PendingIntent&gt; sentPendingIntents = new ArrayList&lt;PendingIntent&gt;();
ArrayList&lt;PendingIntent&gt; deliveredPendingIntents = new ArrayList&lt;PendingIntent&gt;();
for(int i = 0; i&lt;noOfParts; i++){
    PendingIntent newSentPE = PendingIntent.getBroadcast(context, 0, new Intent(ACTION_SMS_SENT), 0);
    sentPendingIntents.add(newSentPE);
    PendingIntent newDeliveredPE = PendingIntent.getBroadcast(context, 0, new Intent(ACTION_SMS_DELIVERED), 0);
    deliveredPendingIntents.add(newDeliveredPE);
}
</code></pre>

<p>Finally I send the SMS and wait for KServer to send back the response. It’s that simple!</p>

<pre><code>smsManager.sendMultipartTextMessage(SMS_SERVER_ADDRESS, null, multipartMessage, sentPendingIntents, deliveredPendingIntents);
 
long startTime = System.currentTimeMillis();
if(waitForResponse){
    while(true){
        long currTime = System.currentTimeMillis();
        long timeDiff = currTime - startTime;
        if(getSharedPreference(context, SP_KEY_SMS_RESPONSE,"").length()&gt;0){
            return getSharedPreference(context, SP_KEY_SMS_RESPONSE,"");
        }
        else if(timeDiff&gt;SMS_RESPONSE_TIMEOUT){
            Log.w(TAG, "SMS response timeout exceeded");
            return null;
        }
    }
}
else{
    return ACKNOWLEDGE_OK;
}    smsManager.sendMultipartTextMessage(SMS_SERVER_ADDRESS, null, multipartMessage, sentPendingIntents, deliveredPendingIntents);
 
long startTime = System.currentTimeMillis();
if(waitForResponse){
    while(true){
        long currTime = System.currentTimeMillis();
        long timeDiff = currTime - startTime;
        if(getSharedPreference(context, SP_KEY_SMS_RESPONSE,"").length()&gt;0){
            return getSharedPreference(context, SP_KEY_SMS_RESPONSE,"");
        }
        else if(timeDiff&gt;SMS_RESPONSE_TIMEOUT){
            Log.w(TAG, "SMS response timeout exceeded");
            return null;
        }
    }
}
else{
    return ACKNOWLEDGE_OK;
}
</code></pre>

<p>As you can see from the code above, waiting for KServer’s response is an endless loop that terminates only when the ENTIRE response is received (put inside the SharedPreference <em>SP_KEY_SMS_RESPONSE</em>) or when it timesout.</p>

<p>I say ENTIRE because the server might respond with a large message that will be split into more than one SMSs. What MistroSMSReceiver does to handle this is:</p>

<ul>
  <li>It listens for when an SMS is received.</li>
  <li>If an SMS is received and the SMS is from KServer, it first gets the value of the SharedPreference <em>SP_KEY_SMS_CACHE</em> (which has a default value of an empty string), then it appends the SMS to the value of <em>SP_KEY_SMS_CACHE</em> then:</li>
  <li>IT checks for whether the resultant message is a valid json string or if it one of the predefined flags. </li>
  <li>If so the message is saved in the SharedPreference <em>SP_KEY_SMS_RESPONSE</em>.</li>
  <li>Otherwise the message is cached in the SharedPreference <em>SP_KEY_SMS_CACHE</em> while MistroSMSReceiver waits for the rest of the SMS fragments.</li>
</ul>

<h3 id="whats-next">What’s next</h3>

<p>There are still some things that I need to figure out:</p>

<ol>
  <li>How to ensure the order of SMSs (making up a split message) is maintained when reconstructing a message.</li>
  <li>How to compress messages before sending them over SMS. Here’s a <a href="http://www.davidhampgonsalves.com/Compress-JSON.js/">nice post</a> how to do it.</li>
</ol>

					<hr>
				</section>
            <section>
               
                      <div id="disqus_thread"></div>
                         <script type="text/javascript">
                             /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
                             var disqus_shortname = 'jasonrogena'; // required: replace example with your forum shortname

                             /* * * DON'T EDIT BELOW THIS LINE * * */
                             (function() {
                                 var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                                 dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                                 (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                             })();
                         </script>
                         <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                         <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
               
            </section>
				<section style="font-weight:bold; margin-bottom: 2em;">
					
						 
							<a rel="next" style="float:right" class="a-hover"href="/2014/01/18/kannel-and-the-huawei-e160.html">Kannel and The Huawei E160 <i class=" icon-double-angle-right"></i></a>
					
				</section>
			</article>
		</div>
	</section>
</main>


	<footer>
		<div class="container">
			Jason Rogena. All Wrongs Reserved
		</div>
	</footer>

	<!-- Footer
	    ================================================== -->

	<!-- Javascripts 
	    ================================================= -->
	<script src="/js/jquery.min.js"></script>
	<script src="/js/custom.js"></script>

    <!-- Analytics
    ================================================== -->
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-54526143-1', 'auto');
        ga('send', 'pageview');
    </script>
	</body>
</html>
